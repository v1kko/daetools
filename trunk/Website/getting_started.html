<!DOCTYPE HTML PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" lang="en"><head>
  
  <meta name="Description" content="" />

  
  <meta name="Keywords" content="DAE Tools Project, pyDAE, cxxDAE, dynamic modelling, simulation, partial differential equations, dae, pdae, equation-oriented modelling" />

  
  <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" />

  
  <meta name="Distribution" content="Copyrighted" />

  
  <meta name="Author" content="Dragan Nikolic - dnikolic@daetools.com" />

  
  <meta name="Robots" content="index,follow" />

  
  <link rel="stylesheet" href="images/dae.css" type="text/css" />
  <title>DAE Tools project</title>

  
  
  <meta http-equiv="REFRESH" content="0; url=http://daetools.sourceforge.net/w/index.php/Getting_started" />

</head><body>
<!-- wrap starts here -->
<div id="wrap">
<div id="header">
<div id="header-content">
<h1 id="logo"><a href="index.html" title="">DAE Tools<span class="gray">
Project</span></a></h1>
<h2 id="slogan">Model the world freely...</h2>
<!-- Menu Tabs -->
<ul>
  <li><a href="index.html">Home</a></li>
  <li><a href="news.html">News</a></li>
  <li><a href="downloads.html">Downloads</a></li>
  <li><a href="documentation.html" id="current">Documentation</a></li>
  <li><a href="https://sourceforge.net/projects/daetools">Source Forge</a></li>
  <li><a href="contact.html">About</a></li>
</ul>
</div>
</div>
<!-- content-wrap starts here -->
<div id="content-wrap">
<div id="content">
<div id="sidebar">
<div class="sidebox">
<h1 class="clear">Getting Started</h1>
<ul class="sidemenu">
  <li><a href="#Programming_language">Programming language</a></li>
  <li><a href="#The_main_concepts">The main concepts</a></li>
  <li><a href="#Running_a_simulation">Running a simulation</a></li>
  <li><a href="#Running_an_optimization">Running an optimization</a></li>
  <li><a href="#Modelling" class="top">Modelling</a></li>
  <li>
    <p><a href="#Models" id="current">Models</a></p>
    <p><a href="#Distribution_domains">Distribution Domains</a></p>
    <p><a href="#Parameters">Parameters</a></p>
    <p><a href="#Variables">Variables</a></p>
    <p><a href="#Equations">Equations</a></p>
    <p><a href="#State_transition_networks">STNs</a></p>
    <p><a href="#Ports">Ports</a></p>
  </li>
  <li><a href="#Simulation">Simulation</a></li>
  <li><a href="#Optimization">Optimization</a></li>
  <li><a href="#Processing_of_the_results">Processing the
results</a></li>
</ul>
</div>
</div>
<div id="main">
<div class="post"><!-- Getting Started   -->
<h1><a name="Getting_Started">Getting Started</a></h1>
<p><a name="Getting_Started">This chapter gives the basic
information about what is needed to develop a model of a
process, how to simulate /optimize it and how to obtain and plot
the results of a process simulation/optimization. In general,&nbsp;<span style="font-weight: bold;">the simulation/optimization of a
process consists
of three tasks:</span></a></p>
<ol>
<a name="Getting_Started">  </a><li><a name="Getting_Started">Modelling of a proces<br />
  </a></li>
<a name="Getting_Started">  </a><li><a name="Getting_Started">Defining a simulation/optimization</a></li>
<a name="Getting_Started">  </a><li><a name="Getting_Started">Processing the results</a></li>
</ol>
<h2><a name="Programming_language">Programming language</a></h2>
<p><span style="font-weight: bold;"><a name="Programming_language">DAE Tools</a></span><a name="Programming_language"> core libraries are
written in standard c++. However, </a><a href="http://www.python.org/">Python</a>
programming language is used
as the main modelling language. The main reason for use of Python is
(as the authors say):&nbsp; <span style="font-style: italic;">"Python
is an easy to learn, powerful programming language. It has efficient
high-level data structures and a simple but effective approach to
object-oriented programming. Python&#8217;s elegant syntax and dynamic
typing, together with its interpreted nature, make it an ideal language
for scripting and rapid application development in many areas on most
platforms" <a href="http://docs.python.org/tutorial/"><sup>[*]</sup></a></span>.<span style="font-style: italic;"> </span>And: "<span style="font-style: italic;">Often, programmers fall in love with
Python because of the increased productivity it provides. Since there
is no compilation step, the edit-test-debug cycle is incredibly fast" </span><span style="font-style: italic;"><a href="http://www.python.org/doc/essays/blurb/"><sup>[*]</sup></a></span><span style="font-style: italic;">. Also, please have a look on <a href="http://www.python.org/doc/essays/comparisons/">a comparison to
the other languages</a>. Based on the information available online, and
according to the personal experience, the python programs are much
shorter and take an order of magnitude less time to develop it.
Initially I developed daePlotter module in c++; it took me about one
month of part time coding. But, then I moved to python:&nbsp;
reimplementing it in PyQt took me just two days (with several new
features added), while
the code size shrank from 24 cpp modules to four python modules only! <span style="font-style: italic;">"Where Python code is typically 3-5 times
shorter than equivalent Java code, it is often 5-10 times shorter than
equivalent C++ code! Anecdotal evidence suggests that one Python
programmer can finish in two months what two C++ programmers can't
complete in a year. Python shines as a glue language, used to combine
components written in C++"</span><span style="font-style: italic;"> </span><span style="font-style: italic;"><a href="http://www.python.org/doc/essays/comparisons/"><sup>[*]</sup></a></span><span style="font-style: italic;">. Obviously, not everything can be
developed in python; for complex projects I still prefer the heavy c++
artillery.</span></span></p>
<h2><a name="The_main_concepts">The main concepts<br />
</a></h2>
<p><a name="The_main_concepts">To efficiently model a real world user should be familiar with the
following concepts<span style="font-weight: bold;">:</span></a></p>
<ul>
<a name="The_main_concepts">  </a><li><span style="font-weight: bold;"><a name="The_main_concepts">Model<br />
    </a></span><a name="The_main_concepts">A model of the
process is a simplified abstraction of real world process/phenomena
describing its most important/driving elements and their interactions.
In <span style="font-weight: bold;">DAE Tools</span> models are
created by defining their parameters,
distribution domains, variables, equations, and ports. </a></li>
<a name="The_main_concepts">  </a><ul>
<a name="The_main_concepts">    </a><li><span style="font-weight: bold;"><a name="The_main_concepts">Distribution domain</a></span><a name="The_main_concepts"><br />
Domain is a general term used
to define an array of different objects (parameters, variables,
equations but models and ports as well).<br />
    </a></li>
<a name="The_main_concepts">    </a><li><span style="font-weight: bold;"><a name="The_main_concepts">Parameter</a></span><a name="The_main_concepts"> <br />
Parameter can be defined as a time invariant quantity that will not
change during
a simulation.<br />
    </a></li>
<a name="The_main_concepts">    </a><li><span style="font-weight: bold;"><a name="The_main_concepts">Variable</a></span><a name="The_main_concepts"> <br />
Variable can be defined as a time variant quantity, also called a <span style="font-style: italic;">state variable</span>.<br />
    </a></li>
<a name="The_main_concepts">    </a><li style="font-weight: bold;"><a name="The_main_concepts">Equation<br />
      <span style="font-weight: normal;">Equation can be defined as an
expression used to calculate a variable value, which can be created by
performing basic mathematical operations (+, -, *, /) and functions
(such as sin, cos, tan, sqrt, log, ln, exp, pow, abs etc) on
parameter and variable values (and time and partial derivatives as well)</span>.<br />
    </a></li>
<a name="The_main_concepts">    </a><li><span style="font-weight: bold;"><a name="The_main_concepts">State transition network</a></span>
<a name="The_main_concepts">      <br />
State transition networks are used to model a special type of
equations: <span style="font-style: italic;">discontinuous equation</span>s.
Discontinuous
equations
are
equations
that
take
different
forms
subject
to
certain
conditions.
They
are
composed
of
a
finite
number of <span style="font-style: italic;">states.</span><br />
    </a></li>
<a name="The_main_concepts">    </a><li style="font-weight: bold;"><a name="The_main_concepts">State<br />
      <span style="font-weight: normal;">States can be defined as a set
of actions (in our case a set of equations) </span><span style="font-weight: normal;">under current operating conditions. In
addition, every
state contains </span><span style="font-weight: normal;">a set of
state transitions which describe conditions when the state changes
occur.</span><br />
    </a></li>
<a name="The_main_concepts">    </a><li><span style="font-weight: bold;"><a name="The_main_concepts">State Transition</a></span><a name="The_main_concepts"><br />
State transition can be defined as a transition from the current to
some other state, subject to given conditions. <br />
    </a></li>
<a name="The_main_concepts">    </a><li><span style="font-weight: bold;"><a name="The_main_concepts">Port</a></span><a name="The_main_concepts"><br />
Ports are objects used to connect two models. Like models, they may
contain
domains, parameters and variables. <br />
    </a></li>
<a name="The_main_concepts">  </a></ul>
<a name="The_main_concepts">  </a><li style="font-weight: bold;"><a name="The_main_concepts">Simulation<br />
    <span style="font-weight: normal;">Simulation of a process can be
considered as the model run for certain input conditions.</span> <span style="font-weight: normal;">To define a simulation, several tasks are
necessary such as: specifying information about domains and parameters,
fixing the degrees of freedom by assigning values to certain variables,
setting the initial conditions and many other (setting the initial
guesses,
absolute tolerances, etc).</span></a></li>
<a name="The_main_concepts">  </a><li style="font-weight: bold;"><span style="font-weight: normal;"><span style="font-weight: bold;"><a name="The_main_concepts">Optimization</a></span><a name="The_main_concepts"><br />
Process optimization can be considered as a process adjustment so as to
minimize or maximize&nbsp; a specified goal while satisfying imposed
set of constraints. The most common goals are minimizing cost,
maximizing throughput, and/or efficiency. In general there are
three&nbsp; types of parameters that can be adjusted to affect optimal
performance:<br />
&nbsp; - Equipment optimization<br />
&nbsp; - Operating procedures<br />
&nbsp; - Control optimization <br />
    </a></span></li>
<a name="The_main_concepts">  </a><li><span style="font-weight: bold;"><a name="The_main_concepts">Solver</a></span><a name="The_main_concepts"><br />
Solver is a set of mathematical procedures/algorithms necessary to
solve a given set of equations. There are several types of solvers:
Linear Algebraic solvers (<span style="font-weight: bold;">LA</span>),
used to solve linear systems of equations; Nonlinear
Algebraic solvers (<span style="font-weight: bold;">NLA</span>), used
to solve non-linear systems of equations;&nbsp; Differential
Algebraic solvers (<span style="font-weight: bold;">DAE</span>), used
to solve mixed systems of differential and algebraic
equations; Nonlinear Programming solvers (<span style="font-weight: bold;">NLP</span>), used
to solve nonlinear optimization problems;&nbsp; Mixed-integer Nonlinear
Programming solvers (<span style="font-weight: bold;">MINLP</span>),
used
to solve mixed-integer nonlinear optimization problems. In <span style="font-weight: bold;">DAE Tools</span> it is
possible to choose <span style="font-weight: bold;">DAE</span>
(currently only </a><a href="https://computation.llnl.gov/casc/sundials/main.html">Sundials
IDAS</a>), <span style="font-weight: bold;">NLP/MINLP</span>
(currently only <a href="https://projects.coin-or.org/Bonmin">IPOPT/BONMIN</a>),
and <span style="font-weight: bold;">LA</span> solvers
(built-in Sundials LA solvers; <a href="http://trilinos.sandia.gov/packages/amesos/">Trilinos Amesos</a>:
    <a href="http://crd.lbl.gov/%7Exiaoye/SuperLU/index.html">SuperLU</a>,
    <a href="http://www.cise.ufl.edu/research/sparse/umfpack">Umfpack</a>,
or <a href="http://www.netlib.org/Lapack">Lapack</a>; <a href="http://software.intel.com/en-us/intel-mkl/">Intel MKL</a>; <a href="http://www.amd.com/acml">AMD ACML</a>).<br />
  </li>
  <li style="font-weight: bold;">Data Reporter<br />
    <span style="font-weight: normal;">Data reporter is defined as
an object used to report the results of a simulation/optimization. They
can either
keep the results internally (and export them into a file, for instance)
or send them
via TCP/IP protocol to the <span style="font-weight: bold;">DAE Tools</span>
plotter.</span><br />
  </li>
  <li style="font-weight: bold;">Data Receiver<br />
    <span style="font-weight: normal;">Data receiver can be defined as
on object which duty is to receive the results from a data reporter.
These data can be later plotted or processed in some other ways.</span><br />
  </li>
  <li><span style="font-weight: bold;">Log</span><br />
Log is defined as an object used to send messages from the various
parts
of <span style="font-weight: bold;">DAE Tools</span> framework
(messages from solvers or simulation).<br />
  </li>
</ul>
<h2><a name="Running_a_simulation">Running a simulation<br />
</a></h2>
<p><a name="Running_a_simulation">Two steps are needed to run a simulation:<br />
</a></p>
<ul>
<a name="Running_a_simulation">  </a><li><a name="Running_a_simulation">Start <span style="font-weight: bold;">daePlotter</span>:</a></li>
</ul>
<pre><span style="font-weight: bold;"><a name="Running_a_simulation">In GNU/Linux:</a></span><a name="Running_a_simulation"><br />go to: <span style="font-weight: bold;">Applications/Programming/daePlotter</span><br />or type the following shell command: <span style="font-weight: bold;">daeplotter</span><br /><br /><span style="font-weight: bold;">In Windows:</span><br />go to: <span style="font-weight: bold;">Start/Programs/DAE Tools/daePlotter</span><br /></a></pre>
<div style="text-align: left;">
<p><a name="Running_a_simulation">&nbsp;The <span style="font-weight: bold;">daePlotte</span>r main
window
should appear (given in <span style="font-weight: bold;">Figure 1.</span>)
<br />
</a></p>
</div>
<p style="text-align: center;"><a name="Running_a_simulation"><br />
<img style="width: 406px; height: 240px;" alt="" src="images/Screenshot-DAEPlotter.png" /><br />
</a></p>
<div style="text-align: center;"><span style="font-weight: bold;"><a name="Running_a_simulation">Figure
1.
daePlotter
main
window<br />
<br />
</a></span><span style="font-weight: bold;">
<p style="text-align: left;"><span style="font-weight: bold;"><a name="Running_a_simulation">daePlotter</a></span>
<a name="Running_a_simulation">can be also added to a panel. Simply add a custom application launcher
(command:
daeplotter)</a></p>
<span style="font-weight: bold;"><span style="font-weight: bold;">
<p style="text-align: left;"><a name="Running_a_simulation"><br />
</a></p>
<div style="text-align: left;">
<p><span style="font-weight: bold;" /></p>
<p><span style="font-weight: bold;" /></p>
</div>
</span></span></span></div>
<ul>
<a name="Running_a_simulation">  </a><li><a name="Running_a_simulation">Start <span style="font-weight: bold;">DAE Tools Examples</span>
program to try some examples:</a></li>
</ul>
<pre><span style="font-weight: bold;"><a name="Running_a_simulation">In GNU/Linux:<br /></a></span><a name="Running_a_simulation">go to: <span style="font-weight: bold;">Applications/Programming/DAE Tools Examples<br /></span>or type the following shell command: <span style="font-weight: bold;">daeexamples</span><br /><br /><span style="font-weight: bold;"><span style="font-weight: bold;">In Windows:</span><br />go to: <span style="font-weight: bold;">Start/Programs/DAE Tools/</span><span style="font-weight: bold;">DAE Tools Examples<br /><br /></span></span></a></pre>
<p><a name="Running_a_simulation">In general, simulations are started by typing the following shell
commands (GNU/Linux and Windows):</a></p>
<pre><a name="Running_a_simulation">$ cd "directory where simulation file is located"<br />$ python mySimulation.py<br /></a></pre>
<p><a name="Running_a_simulation">The main window of <span style="font-weight: bold;">DAE Tools
Examples</span> application is
given in <span style="font-weight: bold;">Figure 2a.</span> while the
output from the simulation run in<span style="font-weight: bold;"> </span><span style="font-weight: bold;">Figure 2b. </span>Users can select one of
several tutorials, run them, and inspect their source
code or model reports. Model reports open in a new window of the
system's default web browser (however, only Mozilla Firefox is
currently
supported because of the MathML rendering issue).<br />
<span style="font-weight: bold;"><br />
</span></a></p>
<p style="text-align: center;"><span style="font-weight: bold;"><a name="Running_a_simulation"><img style="width: 515px; height: 199px;" alt="" src="images/Screenshot-DAEToolsTutorials.png" /><br />
</a></span></p>
<div style="text-align: center;"><span style="font-weight: bold;"><a name="Running_a_simulation">Figure
2a.
DAE
Tools
Examples
main
window<br />
<br />
</a></span><span style="font-weight: bold;"><a name="Running_a_simulation"><img style="width: 602px; height: 674px;" alt="" src="images/Screenshot-DAEToolsTutorials-Run.png" /></a></span><a name="Running_a_simulation"><br />
<span style="font-weight: bold;" /></a></div>
<div style="text-align: center;"><span style="font-weight: bold;"><a name="Running_a_simulation">Figure
2b.
A
typical
optimization output
from
DAE
Tools</a></span><a name="Running_a_simulation"><br />
<span style="font-weight: bold;" /></a></div>
<p><a name="Running_a_simulation"><br />
</a></p>
<p><a name="Running_a_simulation">The simulation can also be started from the shell. The sample output
is given in<span style="font-weight: bold;"> </span><span style="font-weight: bold;">Figure
3.<br />
<br />
</span></a></p>
<div style="text-align: center;"><a name="Running_a_simulation"><img style="width: 404px; height: 600px;" alt="" src="images/Screenshot-RunningSimulation.png" /><br />
</a></div>
<div style="text-align: center;"><span style="font-weight: bold;"><a name="Running_a_simulation">Figure
3.
Shell
output
from
the
simulation<br />
</a></span><span style="font-weight: bold;">
</span></div>
<p><a name="Running_a_simulation"><br />
</a></p>
<h2><a name="Running_an_optimization">Running an optimization<br />
</a></h2>
<p><a name="Running_an_optimization">Running the optimization problems is analogous to running a
simulation.<br />
</a></p>
<h2><a name="Modelling">Modelling</a></h2>
<p><a name="Modelling">In general, three approaches to process modelling exist </a><a href="#1_Morton_W._Equation-oriented"><sup>[1]</sup></a>:<br />
</p>
<ul>
  <li>Sequential Modular (<span style="font-weight: bold;">SeqM</span>)
approach<br />
  </li>
  <li>Simultaneous Modular (<span style="font-weight: bold;">SimM</span>)
approach</li>
  <li>Equation-Oriented (<span style="font-weight: bold;">EO</span>)
approach</li>
</ul>
<p> &nbsp; The pros &amp; cons of the first two approaches are
extensively studied in the literature. Under the <span style="font-weight: bold;">EO</span> approach we generate and gather
together all equations and variables which constitute the model
representing the process. The equations are solved simultaneously using
a suitable mathematical algorithm <a href="getting_started.html#1_Morton_W._Equation-oriented"><sup>[1]</sup></a>.
Equation-oriented
simulation
requires
simultaneous
solution
of
a
set
of
differential
algebraic
equations
(<span style="font-weight: bold;">DAE</span>)
which
itself
requires
a
solution
of
a
set
of nonlinear algebraic
equations (<span style="font-weight: bold;">NLAE</span>) and linear
algebraic equations (<span style="font-weight: bold;">LAE</span>). The
Newton's method or some variant of it is almost always used to solve
problems described by NLAEs. A brief history of Equation-Oriented
solvers and comparison of <span style="font-weight: bold;">SeqM</span>
and <span style="font-weight: bold;">EO</span> approaches as well as
descriptions of the simultaneous modular and equation-oriented methods
can be found in <a href="getting_started.html#1_Morton_W._Equation-oriented"><sup>[1]</sup></a>.
Also
a
good
overview
of
the
equation-oriented
approach
and
its
application
in
<a href="http://www.psenterprise.com/gproms/">gPROMS</a>
is given by Barton &amp; Pantelides <sup><a href="#Pantelides_C._C._and_P._I._Barton1">[2]</a>, <a href="#Barton_P._I._and_C._C._Pantelides2">[3]</a>, <a href="#Barton_P._I._and_C._C._Pantelides3">[4]</a></sup>. <br />
</p>
<p><span style="font-weight: bold;">DAE Tools</span> use
the Equation-Oriented approach to process
modelling, and the following
types of processes can be modelled: <br />
</p>
<ul>
  <li>Lumped and distributed</li>
  <li>Steady-state and dynamic<br />
  </li>
</ul>
<p>Problems can be
formulated as linear, non-linear, and (partial) differential algebraic
systems (of index 1). The most common problems are initial value
problems of implicit form. Equations can be ordinary or
discontinuous, where discontinuities are automatically handled by the
framework. A good overview of discontinuous equations and a procedure
for location of equation discontinuities is given by Park &amp; Barton <a href="#Park_T._and_P._I._Barton"><sup>[5]</sup></a> and in Sundials
IDA <a href="https://computation.llnl.gov/casc/sundials/documentation/ida_guide/node3.html#SECTION00330000000000000000">documentation</a>
(used in DAE Tools).&nbsp; </p>
<p><br />
</p>
<p><sup><a name="1_Morton_W._Equation-oriented" /></sup><a name="1_Morton_W._Equation-oriented"><small><span style="font-weight: bold;">[1]</span> Morton, W., Equation-Oriented
Simulation and Optimization. <span style="font-style: italic;">Proc.
Indian Natl. Sci. Acad.</span> 2003,
317&#8211;357.<br />
</small></a></p>
<div class="biblio-entry"><a name="1_Morton_W._Equation-oriented"><small>
</small>
</a><div class="biblio-style-ieee">
<p><a name="1_Morton_W._Equation-oriented"><small><span class="biblio-authors" /></small></a><small><a name="Pantelides_C._C._and_P._I._Barton1"><span class="biblio-authors"><span style="font-weight: bold;">[2] </span></span><span class="biblio-authors">Pantelides, C. C., and P. I. Barton, </span><span class="biblio-title">"</span></a><a href="http://www.sciencedirect.com/science/article/B6TFT-44W51XS-1F/2/bf701c7635c1f5bfdff558b9ef69a3c2">Equation-oriented
dynamic
simulation
current
status
and
future
perspectives</a>", <i>Computers
&amp;
Chemical Engineering</i>, vol. 17, no. Supplement 1, pp. 263 -
285, 1993.<span class="biblio-abstract-link"><a href="http://yoric.mit.edu/node/247"><br />
</a></span></small></p>
<small><span class="biblio-abstract-link">
</span></small></div>
</div>
<p><small><span class="biblio-authors"><a name="Barton_P._I._and_C._C._Pantelides2" /></span><span class="biblio-authors"><span style="font-weight: bold;"><a name="Barton_P._I._and_C._C._Pantelides2">[3]</a></span><a name="Barton_P._I._and_C._C._Pantelides2"> </a></span><span class="biblio-authors"><a name="Barton_P._I._and_C._C._Pantelides2">Barton, P. I., and C. C. Pantelides, </a></span><span class="biblio-title"><a name="Barton_P._I._and_C._C._Pantelides2">"</a><a href="http://yoric.mit.edu/biblio/view/246">gPROMS
-
a
Combined
Discrete/Continuous
Modelling
Environment
for
Chemical
Processing
Systems</a>", </span><i>Simulation Series</i>, vol. 25, no.
3, pp. 25-34, 1993.
</small></p>
<p><small><span class="biblio-authors"><a name="Barton_P._I._and_C._C._Pantelides3"><span style="font-weight: bold;">[4]</span> Barton, P. I., and C. C.
Pantelides, </a></span><a name="Barton_P._I._and_C._C._Pantelides3"> <span class="biblio-title">"</span></a><a href="http://dx.doi.org/10.1002/aic.690400608">Modeling of combined
discrete/continuous processes</a>",  <i>AIChE Journal</i>,
vol. 40, pp. 966-979, 1994.<br />
</small></p>
<p><small><span class="biblio-authors"><a name="Park_T._and_P._I._Barton"><span style="font-weight: bold;">[5]</span>
Park, T., and P. I. Barton, </a></span><span class="biblio-title"><a name="Park_T._and_P._I._Barton">"</a><a href="http://yoric.mit.edu/biblio/view/241">State event location in
differential-algebraic models</a>", </span><i>ACM Transactions on
Modeling and Computer Simulation</i>, vol. 6, no. 2, New York, NY, USA,
ACM, pp. 137&#8211;165, 1996.</small>
<br />
</p>
<h3><a name="Models">Models</a></h3>
<p><a name="Models">In <span style="font-weight: bold;">DAE Tools</span> models
are created by defining its parameters,
distribution domains, variables, equations, and ports.
Models are developed by deriving a new class from the base model class
(<span style="font-weight: bold;">daeModel</span>). The process
consists of two steps:<br />
</a></p>
<ol>
<a name="Models">  </a><li><a name="Models">Declare all domains, parameters, variables and ports in <span style="font-style: italic;">__init__</span> function (the
constructor)</a></li>
<a name="Models">  </a><li><a name="Models">Declare equations and state transition networks in <span style="font-style: italic;">DeclareEquations </span>function<br />
  </a></li>
</ol>
<p><a name="Models">Models in <span style="font-weight: bold;">pyDAE</span> (using
python programming language) can be
defined by the following statement:<br />
</a></p>
<pre><a name="Models">class myModel(daeModel):<br />    def __init__(self, Name, Parent = None, Description = ""):<br />        daeModel.__init__(self, Name, Parent, Description)<br />        ... (here go declarations of domains, parameters, variables, ports, etc)<br /><br />    def DeclareEquations(self):<br />        ... (here go declarations of equations and state transitions)<br /></a></pre>
<p><a name="Models">while in <span style="font-weight: bold;">cDAE</span> (using c++
programming language):<br />
</a></p>
<pre><a name="Models">class myModel : public daeModel<br />{<br />public:<br /> &nbsp;&nbsp; myModel(string strName, daeModel* pParent = NULL, string strDescription = "") <br />       : daeModel(strName, pParent, strDescription)<br />    {<br />        ... (here go additional properties of domains, parameters, variables, ports, etc)<br />    }<br /><br />&nbsp;&nbsp;&nbsp; void DeclareEquations(void)<br />&nbsp;&nbsp;&nbsp; {<br />        ... (here go declarations of equations and state transitions)<br />   &nbsp;}<br /><br />public:<br />    ... (here go declarations of domains, parameters, variables, ports, etc)<br />};</a></pre>
<p><a name="Models">More information about developing models can be found in </a><a href="user_guide.html">pyDAE User Guide</a> and <a href="api_ref/core.html#daeModel">pyDAE API Reference</a>. Also, do
not forget to have a look on <a href="tutorials.html">tutorials</a>.</p>
<h3><a name="Distribution_domains">Distribution domains</a></h3>
<p><a name="Distribution_domains">There are two types of domains in <span style="font-weight: bold;">DAE
Tools</span>: simple arrays and distributed domains (commonly&nbsp;
used to distribute variables, parameters and equations in space). The
distributed domains can have a uniform (default) or a user specified
non-uniform grid. At the moment, only the following finite difference
methods can be
used to calculate partial derivatives:<br />
</a></p>
<ul>
<a name="Distribution_domains">  </a><li><a name="Distribution_domains">Backward finite difference method (BFD)<br />
  </a></li>
<a name="Distribution_domains">  </a><li><a name="Distribution_domains">Forward finite difference method (FFD)<br />
  </a></li>
<a name="Distribution_domains">  </a><li><a name="Distribution_domains">Center finite difference method (CFD)<br />
  </a></li>
</ul>
<p><a name="Distribution_domains">In <span style="font-weight: bold;">DAE Tools</span> just anything
can be distributed on domains:
parameters, variables, equations even models and ports. Obviously it
does not have a physical meaning to distribute a model on a domain,
However that can be&nbsp; useful for modelling of complex processes
where
we can create an array of models where each point in a distributed
domain have a corresponding model so that a user does not have to take
care of number of points in the domain, etc. In addition, domain points
values
<span style="font-style: italic;">can be obtained as a <span style="font-weight: bold;">NumPy</span>
one-dimensional array; this way <span style="font-weight: bold;">DAE
Tools</span> can be easily used in conjuction with other scientific
python libraries (</span></a><a href="http://numpy.scipy.org/">NumPy</a>, <a href="http://www.scipy.org">SciPy</a>, for instance and many <a href="http://www.scipy.org/Projects">other</a>)<span style="font-style: italic;">.<br />
</span></p>
<p>Domains in <span style="font-weight: bold;">pyDAE</span> can be
defined by the following statement:</p>
<pre>myDomain = daeDomain("myDomain", Parent_Model_or_Port, Description)</pre>
<p>while in <span style="font-weight: bold;">cDAE</span>:<br />
</p>
<pre>daeDomain myDomain("myDomain", &amp;Parent_Model_or_Port, Description);</pre>
<p>More information about domains can be found in <a href="user_guide.html">pyDAE User Guide</a> and <a href="api_ref/core.html#daeDomain">pyDAE API Reference</a>. Also, do
not forget to have a look on <a href="tutorials.html">tutorials</a>.</p>
<h3><a name="Parameters">Parameters</a></h3>
<p><a name="Parameters">There are two types of parameters in <span style="font-weight: bold;">DAE Tools</span>: ordinary and distributed.
Several functions to get a parameter value (the function
call
operator)&nbsp;<span style="font-style: italic;"><span style="font-style: italic;"><span style="font-style: italic;">and
array
of
values
(the
function
<span style="font-style: italic;">array</span><span style="font-style: italic;"><span style="font-style: italic;">)
have
been
defined.
In
addition,
distributed
parameters
have
<span style="font-style: italic;">GetNumPyArray</span>
function to get the
values as a numpy multi-dimensional array<span style="font-style: italic;">.</span><br />
</span></span></span></span></span></a></p>
<p><a name="Parameters">Parameters in <span style="font-weight: bold;">pyDAE</span> can be
defined by the following statement:</a></p>
<pre><a name="Parameters">myParam = daeParameter("myParam", eReal, Parent_Model_or_Port, "Description")</a></pre>
<p><a name="Parameters">while in <span style="font-weight: bold;">cDAE</span>:<br />
</a></p>
<pre><a name="Parameters">daeParameter myParam("myParam", eReal, &amp;Parent_Model_or_Port, "Description");</a></pre>
<p><a name="Parameters">More information about parameters can be found in </a><a href="user_guide.html">pyDAE User Guide</a> and <a href="api_ref/core.html#daeParameter">pyDAE API Reference</a>. Also,
do not forget to have a look on <a href="tutorials.html">tutorials</a>.</p>
<h3><a name="Variables">Variables</a></h3>
<p><a name="Variables">There are two types of variables in <span style="font-weight: bold;">DAE
Tools</span>: ordinary and distributed. Functions to get a
variable value (function call operator), a time or a partial
derivative (<span style="font-style: italic;">dt</span>, <span style="font-style: italic;">d</span>, or <span style="font-style: italic;">d2</span>) or functions to obtain an array
of values, time or partial derivatives (<span style="font-style: italic;">array,
dt_array</span>, <span style="font-style: italic;">d_array</span>, or <span style="font-style: italic;">d2_array</span>) have been defined. In
addition, distributed variables have <span style="font-style: italic;">GetNumPyArray</span>
function to get the values as a numpy multi-dimensional array<span style="font-style: italic;">.<br />
</span></a></p>
<p><a name="Variables">Variables in <span style="font-weight: bold;">pyDAE</span> can be
defined by the following statement:</a></p>
<pre><a name="Variables">myVar = daeVariable("myVar", variableType, Parent_Model_or_Port, "Description")</a></pre>
<p><a name="Variables">while in <span style="font-weight: bold;">cDAE</span>:<br />
</a></p>
<pre><a name="Variables">daeVariable myVar("myVar", variableType, &amp;Parent_Model_or_Port, "Description");</a></pre>
<p><a name="Variables">More information about variables can be found in </a><a href="pydae_user_guide.html">pyDAE User Guide</a> and <a href="api_ref/core.html#daeVariable">pyDAE API Reference</a>. Also, do
not forget to have a look on <a href="tutorials.html">tutorials</a>.<br />
</p>
<h3><a name="Equations">Equations</a></h3>
<p><span style="font-weight: bold;"><a name="Equations">DAE Tools</a></span><a name="Equations"> introduce two
types of equations: ordinary and distributed.
What makes distributed equations special is that an equation expression
is valid on every point within the domains that the equations is
distriibuted on. Equations can be distributed on a whole domain, on a
part of it or on some of the points in a domain.<br />
</a></p>
<p><a name="Equations">Equations in <span style="font-weight: bold;">pyDAE</span> can be
defined by the following statement:</a></p>
<pre><a name="Equations">eq = model.CreateEquation("myEquation", "Description")</a></pre>
<p><a name="Equations">while in <span style="font-weight: bold;">cDAE</span>:<br />
</a></p>
<pre><a name="Equations">daeEquation* eq = model.CreateEquation("myEquation", "Description");</a></pre>
<p>
</p>
<p><a name="Equations">To define an equation expression (used to calculate its residual and
its gradiant - which represent a single row in a Jacobian matrix) <span style="font-weight: bold;">DAE Tools </span>combine
the
</a><a href="http://en.wikipedia.org/wiki/Automatic_differentiation#Operator_overloading">operator
overloading</a> technique for <a href="http://en.wikipedia.org/wiki/Automatic_differentiation">automatic
differentiation</a> (adopted from <a href="https://projects.coin-or.org/ADOL-C"><span style="font-weight: bold;">ADOL-C</span></a> library) with the concept
of representing equations as <span style="font-weight: bold;">evaluation
trees</span>. Evaluation trees are made of binary or unary nodes,
itself representing four basic mathematical operations and frequently
used mathematical functions, such as sin, cos, tan, sqrt, pow, log, ln,
exp, min, max,&nbsp; floor, ceil, abs, sum, product, ...). These basic
mathematical operations and functions are implemented to operate on <span style="font-weight: bold;">a heavily modified ADOL-C</span> library
class <span style="font-weight: bold;">adouble </span>(which has been
extended to contain information about domains/parameters/variables
etc). In
adition, a new <span style="font-weight: bold;">adouble_array </span>class
has
been
introduced
to
apply
all
above-mentioned
operations
on
arrays
of
variables.&nbsp;
What
is
different
here
is
that
<span style="font-weight: bold;">adouble</span>/<span style="font-weight: bold;">adouble_array</span>
classes
and
mathematical
operators/functions work in two modes; they can either <span style="font-weight: bold;"> <span style="font-weight: bold;">build-up
an
evaluation
tree
</span>or <span style="font-weight: bold;">calculate a value of
an expression</span>.
Once built the evaluation trees can be used to calculate equation
residuals or
derivatives to fill a Jacobian matrix necessary for a Newtown-type
iteration. A typical evaluation tree is presented in <span style="font-weight: bold;">Figure 4.</span> below.<br />
</span></p>
<p><br />
</p>
<div style="text-align: center;"><img style="width: 378px; height: 416px;" alt="Evaluation tree" title="Evaluation tree" src="images/EvaluationTree.png" /><br />
<span style="font-weight: bold;"><a name="Figure_1._DAE_Tools_equation_evaluation">Figure 4. DAE Tools
equation evaluation tree</a></span><a name="Figure_1._DAE_Tools_equation_evaluation"><br />
</a><div style="text-align: left;">
<p><a name="Figure_1._DAE_Tools_equation_evaluation"><br />
</a></p>
<div style="text-align: justify;">
<p><a name="Figure_1._DAE_Tools_equation_evaluation">As it has been noted before, domains, parameters, and variables
contain
functions that return <span style="font-weight: bold;">adouble</span>/<span style="font-weight: bold;">adouble_array</span> objects, which can be
used
to calculate residuals and derivatives. These functions include
functions to get a
value of a domain/parameter/variable (function call operator), to get a
time or a partial
derivative of a variable (functions <span style="font-style: italic;">dt</span>,
<span style="font-style: italic;">d</span>, or <span style="font-style: italic;">d2</span>) or functions to obtain an array
of values, time or partial derivatives (<span style="font-style: italic;">array,
dt_array</span>, <span style="font-style: italic;">d_array</span>, or <span style="font-style: italic;">d2_array</span>). Another useful feature
of <span style="font-weight: bold;">DAE Tools</span>
equations is that they can be exported into
MathML or Latex format and easily visualized.</a></p>
</div>
<p><a name="Figure_1._DAE_Tools_equation_evaluation">For example, the equation <span style="font-style: italic;">F</span>
(given in <span style="font-weight: bold;">Figure 4.</span>) can be
defined in <span style="font-weight: bold;">pyDAE </span>by using the
following
statements:<br />
</a></p>
<pre><a name="Figure_1._DAE_Tools_equation_evaluation">F = model.CreateEquation("F", "F description")<br />F.Residal = V14.dt() + V1() / (V14() + 2.5) + sin(3.14 * V3())<br /></a></pre>
<p><a name="Figure_1._DAE_Tools_equation_evaluation">while in <span style="font-weight: bold;">cDAE</span> by:<br />
</a></p>
<pre><a name="Figure_1._DAE_Tools_equation_evaluation">daeEquation* F = model.CreateEquation("F", "F description");<br />F-&gt;SetResidal( V14.dt() + V1() / (V14() + 2.5) + sin(3.14 * V3()) );</a></pre>
</div>
</div>
<p><a name="Figure_1._DAE_Tools_equation_evaluation">More information about equations can be found in </a><a href="pydae_user_guide.html">pyDAE User Guide</a> and <a href="api_ref/core.html#daeEquation">pyDAE API Reference</a>. Also, do
not forget to have a look on <a href="tutorials.html">tutorials</a>.<br />
</p>
<h3><a name="State_transition_networks">State Transition Networks
(Discontinuous equations)</a></h3>
<p><a name="State_transition_networks">Discontinuous equations are equations that take different forms
subject to certain conditions. For example, if we want to model a flow
through a pipe we may observe three different flow regimes:<br />
</a></p>
<ul>
<a name="State_transition_networks">  </a><li><a name="State_transition_networks">Laminar: if Reynolds number is less than 2,100</a></li>
<a name="State_transition_networks">  </a><li><a name="State_transition_networks">Transient: if Reynolds number is greater than 2,100 and less than
10,000</a></li>
<a name="State_transition_networks">  </a><li><a name="State_transition_networks">Turbulent: if Reynolds number is greater than 10,000<br />
  </a></li>
</ul>
<p><a name="State_transition_networks">What we can see is that from any of these three states we can go to
any other state. This type of discontinuities is called a <span style="font-weight: bold;">reversible discontinuity</span> and can be
described by the <span style="font-weight: bold;">IF - ELSE_IF - ELSE
state transient network
construct</span>. In <span style="font-weight: bold;">pyDAE</span>&nbsp;<span style="font-weight: bold;">it is given by the following
statement:<br />
</span></a></p>
<pre><a name="State_transition_networks">IF(Re() &lt;= 2100)                      # (Laminar flow)<br /> ... (equations go here)<br /><br />ELSE_IF(Re() &gt; 2100 and Re() &lt; 10000) # (Transient flow)<br /> ... (equations go here)<br /><br />ELSE()                                # (Turbulent flow)<br /> ... (equations go here)<br /><br />END_IF()<br /></a></pre>
<p><a name="State_transition_networks">while in <span style="font-weight: bold;">cDAE</span> by:</a></p>
<pre><a name="State_transition_networks">IF(Re() &lt;= 2100);                      // (Laminar flow)<br /> ... (equations go here)<br /><br />ELSE_IF(Re() &gt; 2100 and Re() &lt; 10000); // (Transient flow)<br /> ... (equations go here)<br /><br />ELSE();                                // (Turbulent flow)<br /> ... (equations go here)<br /><br />END_IF();</a></pre>
<p><span style="font-weight: bold;"><a name="State_transition_networks">Reversible discontinuities</a></span>
<a name="State_transition_networks">can be <span style="font-weight: bold;">symmetrical</span>
and <span style="font-weight: bold;">non-symmetrical</span>. The above
example is <span style="font-weight: bold;">symmetrical</span>.
However, if we have a CPU and we want to model its power dissipation
we may have three operating modes with the following state transitions:<br />
</a></p>
<ul>
<a name="State_transition_networks">  </a><li><a name="State_transition_networks">Normal mode<br />
&nbsp;&nbsp; - switch to <span style="font-style: italic;">Power
saving mode</span> if <span style="font-style: italic;">CPU load</span>
is below 5%<br />
&nbsp;&nbsp; - switch to <span style="font-style: italic;">Fried mode</span>
if the temperature is <span style="font-style: italic;">above
110<sup>0</sup>C<br />
  </span></a></li>
<a name="State_transition_networks">  </a><li><a name="State_transition_networks">Power saving mode<br />
&nbsp;&nbsp; - switch to <span style="font-style: italic;">Normal mode</span>
if <span style="font-style: italic;">CPU load</span> is above 5%<br />
&nbsp;&nbsp; - switch to <span style="font-style: italic;">Fried mode</span>
if the temperature is <span style="font-style: italic;">above
110<sup>0</sup>C<br />
  </span></a></li>
<a name="State_transition_networks">  </a><li><a name="State_transition_networks">Fried mode (no escape from here... go to the nearest shop and buy
a new one!)<br />
  </a></li>
</ul>
<p><a name="State_transition_networks">What we can see is that from the <span style="font-style: italic;">Normal
mode</span> we can either go to the <span style="font-style: italic;">Power
saving
mode</span> or to the <span style="font-style: italic;">Fried
mode</span>. The same stands for the <span style="font-style: italic;">Power
saving
mode</span>: we can either go to the <span style="font-style: italic;">Normal
mode</span> or to the <span style="font-style: italic;">Fried mode.</span>
However, once the
temperature exceeds 110<sup>0</sup>C the CPU dies (let's say we heavily
overclocked it) and there is no going back. This type of
discontinuities is called an <span style="font-weight: bold;">irreversible
discontinuity</span> and can be described <span style="font-weight: bold;"> by the <span style="font-weight: bold;">STN
</span><span style="font-weight: bold;">state
transient
network
</span><span style="font-weight: bold;">construct</span>. In <span style="font-weight: bold;">pyDAE</span>&nbsp;<span style="font-weight: bold;">it is given by the following
statement:
</span></span></a></p>
<pre><a name="State_transition_networks">STN("CPU")<br /><br />STATE("Normal")<br /> ... (equations go here)<br />SWITCH_TO("PowerSaving", CPULoad() &lt; 0.05) <br />SWITCH_TO("Fried", T() &gt; 110)<br /><br /><br />STATE("PowerSaving") <br /> ... (equations go here)<br />SWITCH_TO("Normal", CPULoad() &gt;= 0.05)<br />SWITCH_TO("Fried", T() &gt; 110)<br /><br />STATE("Normal")<br /> ... (equations go here)<br /><br />END_STN()</a></pre>
<p><a name="State_transition_networks">while in <span style="font-weight: bold;">cDAE</span> by:<br />
</a></p>
<pre><a name="State_transition_networks">STN("CPU");<br /><br />STATE("Normal");<br /> ... (equations go here)<br />SWITCH_TO("PowerSaving", CPULoad() &lt; 0.05); <br />SWITCH_TO("Fried", T() &gt; 110);<br /><br /><br />STATE("PowerSaving");<br /> ... (equations go here)<br />SWITCH_TO("Normal", CPULoad() &gt;= 0.05);<br />SWITCH_TO("Fried", T() &gt; 110);<br /><br />STATE("Normal");<br /> ... (equations go here)<br /><br />END_STN();</a></pre>
<p><a name="State_transition_networks">More information about state transition networks can be found in </a><a href="pydae_user_guide.html">pyDAE User Guide</a> and <a href="api_ref/core.html#daeSTN">pyDAE API Reference</a>. Also, do not
forget to have a look on <a href="tutorials.html">tutorials</a>.<br />
</p>
<h3><a name="Ports">Ports</a></h3>
<p><a name="Ports">Ports are used to connect two models. Like models, they may contain
domains, parameters and variables. For instance, in <span style="font-weight: bold;">pyDAE</span> ports can be defined by the
following
statements:<br />
</a></p>
<pre><a name="Ports">class myPort(daePort):<br />    def __init__(self, Name, Type, Parent = None, Description = ""):<br />        daePort.__init__(self, Name, Type, Parent, Description)<br />        ... (here go declarations of domains, parameters and variables)<br /></a></pre>
<p><a name="Ports">while in <span style="font-weight: bold;">cDAE</span>
by:</a></p>
<pre><a name="Ports">class myPort : public daePort<br />{<br />public:<br /> &nbsp;&nbsp; myPort(string strName, daeePortType eType, daeModel* pParent, string strDescription = "") <br />         : daePort(strName, eType, pParent, strDescription)<br />   &nbsp;{<br />        ... (here go additional properties of domains, parameters and variables)<br />    }<br /><br />public:<br />    ... (here go declarations of domains, parameters and variables)<br />};</a></pre>
<p>
</p>
<p>
</p>
<p><a name="Ports">More information about ports can be found in </a><a href="pydae_user_guide.html">pyDAE User Guide</a> and <a href="api_ref/core.html#daePort">pyDAE API Reference</a>. Also, do not
forget to have a look on <a href="tutorials.html">tutorials</a>.<br />
</p>
<p>
</p>
<h2><a name="Simulation">Simulation</a></h2>
<p><a name="Simulation">As it was mentione above, simulation of a process can be considered
as the model run for
certain
input conditions. To define a simulation in <span style="font-weight: bold;">DAE Tools</span>
the following tasks have
to be done:<br />
</a></p>
<p><a name="Simulation">1. Derive a new simulation class<br />
</a></p>
<ul>
<a name="Simulation">  </a><li><a name="Simulation">Specify a model to simulate</a></li>
<a name="Simulation">  </a><li><a name="Simulation">Specify its domains and parameters information</a></li>
<a name="Simulation">  </a><li><a name="Simulation">Fix the degrees of freedom by assigning the values to certain
variables</a></li>
<a name="Simulation">  </a><li><a name="Simulation">Set the initial conditions for differential variables</a></li>
<a name="Simulation">  </a><li><a name="Simulation">Set the other variables' information: initial guesses, absolute
tolerances, etc</a></li>
<a name="Simulation">  </a><li><a name="Simulation">Specify the operating procedure. It can be either a simple run
for a specified period of time (default)&nbsp; or a complex one where
various actions
can be taken during the simulation</a></li>
</ul>
<p><a name="Simulation">2. Specify DAE and LA solvers<br />
3. Specify a data reporter and a data receiver, and connect them<br />
4. Set a time horizon, reporting interval, etc<br />
5. Do the initialization of the DAE system<br />
6. Save model report and/or runtime model report (to inspect expanded
equations etc)<br />
7. Run the simulation </a></p>
<p><a name="Simulation">Simulations in <span style="font-weight: bold;">pyDAE</span>
can be defined
by the following
construct:<br />
</a></p>
<pre><a name="Simulation">class mySimulation(daeSimulation):<br />    def __init__(self):<br />        daeSimulation.__init__(self)<br />        self.m = myModel("myModel", "Description") <br />          <br />    def SetUpParametersAndDomains(self):<br />        ... (here we set up domains and parameters)<br />    <br />    def SetUpVariables(self):<br />        ... (here we set up degrees of freedom, initial conditions, initial guesses, etc)<br /><br />    def Run(self):<br />        ... (here goes a custom operating procedure, if needed)<br /></a></pre>
<p><a name="Simulation">while in <span style="font-weight: bold;">cDAE</span>
by:</a></p>
<pre><a name="Simulation">class mySimulation : public daeSimulation<br />{<br />public:<br />    mySimulation(void) : m("myModel", "Description")<br />    {<br />        SetModel(&amp;m);<br />    }<br /><br />public:<br />    void SetUpParametersAndDomains(void)<br />    {<br />        ... (here we set up domains and parameters)<br />    }<br /><br />    void SetUpVariables(void)<br />    {<br />        ... (here we set up degrees of freedom, initial conditions, initial guesses, etc)<br />    }<br />    <br />    void Run(void)<br />    {<br />        ... (here goes a custom operating procedure, if needed)<br />    }<br />    <br />public:<br />    myModel m;<br />};</a></pre>
<h3><a name="Simulation">Running a simulation</a></h3>
<p><a name="Simulation">Simulations in <span style="font-weight: bold;">pyDAE</span> can be
run in two modes:<br />
</a></p>
<ol>
<a name="Simulation">  </a><li><a name="Simulation">By using PyQt4 graphical user interface (GUI)</a></li>
<a name="Simulation">  </a><li><a name="Simulation">From the shell</a></li>
</ol>
<p><a name="Simulation"><br />
</a></p>
<p><a name="Simulation">1) Running a simulation from the GUI (<span style="font-weight: bold;">pyDAE</span> only):<br />
</a></p>
<pre><a name="Simulation"># Import modules<br />import sys<br />from time import localtime, strftime<br />from PyQt4 import QtCore, QtGui<br /><br /># Create QtApplication object<br />app = QtGui.QApplication(sys.argv)<br /><br /># Create simulation object<br />sim = simTutorial()<br /><br /># Report ALL variables in the model<br />sim.m.SetReportingOn(True)<br /><br /># Show the daeSimulator window to choose the other information needed for simulation<br />simulator  = daeSimulator(app, simulation=sim)<br />simulator.show()<br /><br /># Execute applications main loop<br />app.exec_()</a></pre>
<p><a name="Simulation">Here the default log, and data reporter objects will be used, while
the user can choose DAE and LA solvers and specify time horizon and
reporting interval.<br />
</a></p>
<p><a name="Simulation"><br />
</a></p>
<p><a name="Simulation">2) Running a simulation from the shell:<br />
</a></p>
<p><a name="Simulation">In <span style="font-weight: bold;">pyDAE</span>:<br />
</a></p>
<pre><a name="Simulation"># Import modules<br />import sys<br />from time import localtime, strftime<br /><br /># Create Log, Solver, DataReporter and Simulation object<br />log          = daeStdOutLog()<br />solver       = daeIDAS()<br />datareporter = daeTCPIPDataReporter()<br />simulation   = simTutorial()<br /><br /># Set the linear solver (optional)<br />lasolver     = pyTrilinosAmesos.CreateTrilinosAmesosSolver("Amesos_Superlu")<br />solver.SetLASolver(eThirdParty, lasolver)<br /><br /># Report ALL variables in the model<br />simulation.m.SetReportingOn(True)<br /><br /># Set the time horizon (1000 seconds) and the reporting interval (10 seconds)<br />simulation.SetReportingInterval(10)<br />simulation.SetTimeHorizon(1000)<br /><br /># Connect data reporter (use the default TCP/IP connection string)<br />simName = simulation.m.Name + strftime(" [%d.%m.%Y %H:%M:%S]", localtime())<br />if(datareporter.Connect("", simName) == False):<br />    sys.exit()<br /><br /># Initialize the simulation<br />simulation.Initialize(solver, datareporter, log)<br /><br /># Solve at time = 0 (initialization)<br />simulation.SolveInitial()<br /><br /># Run<br />simulation.Run()<br />simulation.Finalize()<br /></a></pre>
<p><a name="Simulation">while in <span style="font-weight: bold;">cDAE</span>
by:</a></p>
<pre><a name="Simulation">// Create Log, Solver, DataReporter and Simulation object<br />boost::scoped_ptr&lt;daeSimulation_t&gt;    pSimulation(new simTutorial);  <br />boost::scoped_ptr&lt;daeDataReporter_t&gt;  pDataReporter(daeCreateTCPIPDataReporter());<br />boost::scoped_ptr&lt;daeIDASolver&gt;	      pDAESolver(daeCreateIDASolver());<br />boost::scoped_ptr&lt;daeLog_t&gt;           pLog(daeCreateStdOutLog());<br /><br />// Report ALL variables in the model<br />pSimulation-&gt;GetModel()-&gt;SetReportingOn(true);<br /><br />// Set the time horizon and the reporting interval<br />pSimulation-&gt;SetReportingInterval(10);<br />pSimulation-&gt;SetTimeHorizon(100);<br /> <br />// Connect data reporter<br />string strName = pSimulation-&gt;GetModel()-&gt;GetName();<br />if(!pDataReporter-&gt;Connect("", strName))<br />    return;<br /><br />// Initialize the simulation<br />pSimulation-&gt;Initialize(pDAESolver.get(), pDataReporter.get(), pLog.get());<br /><br />// Solve at time = 0 (initialization)<br />pSimulation-&gt;SolveInitial();<br /><br />// Run<br />pSimulation-&gt;Run();<br />pSimulation-&gt;Finalize();<br /></a></pre>
<p><a name="Simulation"><br />
More information about simulation can be found in </a><a href="pydae_user_guide.html">pyDAE User Guide</a> and <a href="api_ref/activity.html#daeSimulation">pyDAE API Reference</a>.
Also,
do
not
forget
to
have
a
look
on
<a href="tutorials.html">tutorials</a>.<br />
</p>
<p><br />
</p>
<h2><a name="Optimization">Optimization</a></h2>
<p><a name="Optimization">To define an optimization problem it is first necessary to develop a
model of the process and to define a simulation&nbsp; (as explained
above). Having done these tasks (working model and simulation) the
optimization in <span style="font-weight: bold;">DAE Tools</span>
can be defined by specifying the objective function, optimization
variables and optimization constraints. It is intentionally chosen to
keep
simulation and optimization tightly coupled. The optimization problem
is
specified in the function <span style="font-weight: bold;">SetUpOptimization</span>
in the <span style="font-weight: bold;">daeSimulation</span> class.
The tasks have
to be done are:<br />
</a></p>
<p><a name="Optimization">1. Specify the objective function<br />
</a></p>
<ul>
<a name="Optimization">  </a><li><a name="Optimization">Objective function is defined by specifying its residual
(similarly to specifying an equation residual);<br />
Internally the framework will create a new variable (V_obj) and a new
equation (F_obj). <br />
  </a></li>
</ul>
<p><a name="Optimization">2. Specify optimization variables<br />
</a></p>
<ul>
<a name="Optimization">  </a><li><a name="Optimization">The optimization variables have to be already defined in the
model and their values assigned in the simulation; they can be either
non-distributed or distributed.</a></li>
<a name="Optimization">  </a><li><a name="Optimization">Specify a type of optimization variable values. The variables can
be <span style="font-weight: bold;">continuous</span> (floating point
values in the given range), <span style="font-weight: bold;">integer</span>
(set of integer values in the given range) or <span style="font-weight: bold;">binary</span> (integer value: 0 or 1).</a></li>
<a name="Optimization">  </a><li><a name="Optimization">Specify the starting point (within the range)<br />
  </a></li>
</ul>
<p><a name="Optimization">3. Specify optimization constraints</a></p>
<ul>
<a name="Optimization">  </a><li><a name="Optimization">Two types of constraints exist in DAE Tools: <span style="font-weight: bold;">equality</span> and <span style="font-weight: bold;">inequality</span> constraints<br />
To define an <span style="font-weight: bold;">equality</span>
constraint its residual and the value has to be specified;<br />
To define an <span style="font-weight: bold;">inequality</span>
constraint its residual, the lower and upper bounds have to be
specified;<br />
Internally the framework will create a new variable (V_constraint[N])
and a new equation (F_constraint[N]) for each defined constraint, where
N is the ordinal number of the constraint.<br />
  </a></li>
</ul>
<p><a name="Optimization">4. Specify NLP/MINLP solver <br />
</a></p>
<ul>
<a name="Optimization">  </a><li><a name="Optimization">Currently only <span style="font-weight: bold;">BONMIN</span>
MINLP solver is supported; internally it
uses <span style="font-weight: bold;">IPOPT</span> NLP solver to solve
NLP problems</a></li>
</ul>
<p><a name="Optimization">5. Specify DAE and LA solvers<br />
6. Specify a data reporter and a data receiver, and connect them<br />
7. Set a time horizon, reporting interval, etc</a></p>
<p><a name="Optimization">8. Set the options of the MINLP solver<br />
9. Initialize the optimization<br />
10. Save model report and/or runtime model report (to inspect expanded
equations etc)<br />
11. Run the optimization </a></p>
<p><a name="Optimization">SetUpOptimization function is declared in <span style="font-weight: bold;">pyDAE</span>
as the following:<br />
</a></p>
<pre><a name="Optimization">class mySimulation(daeSimulation):<br />    ... (here we set up a simulation)<br /><br />    def SetUpOptimization(self):<br />        ... (here goes a declaration of the obj. function, opt. variables and constraints)<br /></a></pre>
<p><a name="Optimization">while in <span style="font-weight: bold;">cDAE</span>
by:</a></p>
<pre><a name="Optimization">class mySimulation : public daeSimulation<br />{<br />    ... (here we set up a simulation)<br /><br />    void SetUpOptimization(void)<br />    {<br />        ... (here goes a declaration of the obj. function, opt. variables and constraints)<br />    }<br />};</a></pre>
<h3><a name="Optimization">Running the optimization<br />
</a></h3>
<p><a name="Optimization">Optimizations, like simulations in <span style="font-weight: bold;">pyDAE</span>
can be
run in two modes:<br />
</a></p>
<ol>
<a name="Optimization">  </a><li><a name="Optimization">By using PyQt4 graphical user interface (GUI)</a></li>
<a name="Optimization">  </a><li><a name="Optimization">From the shell</a></li>
</ol>
<p><a name="Optimization"><br />
</a></p>
<p><a name="Optimization">1) Running an optimization from the GUI (<span style="font-weight: bold;">pyDAE</span> only):<br />
</a></p>
<pre><a name="Optimization"># Import modules<br />import sys<br />from time import localtime, strftime<br />from PyQt4 import QtCore, QtGui<br /><br /># Create QtApplication object<br />app = QtGui.QApplication(sys.argv)<br /><br /># Create simulation object<br />sim = simTutorial()<br />nlp = daeBONMIN()<br /><br /># Report ALL variables in the model<br />sim.m.SetReportingOn(True)<br /><br /># Show the daeSimulator window to choose the other information needed for optimization<br />simulator = daeSimulator(app, simulation=sim, nlpsolver=nlp)<br />simulator.show()<br /><br /># Execute applications main loop<br />app.exec_()</a></pre>
<p><a name="Optimization">Here the default log, and data reporter objects will be used, while
the user can choose NLP, DAE and LA solvers and specify time horizon
and
reporting interval.<br />
</a></p>
<p><a name="Optimization"><br />
</a></p>
<p><a name="Optimization">2) Running a simulation from the shell:<br />
</a></p>
<p><a name="Optimization">In <span style="font-weight: bold;">pyDAE</span>:<br />
</a></p>
<pre><a name="Optimization"># Import modules<br />import sys<br />from time import localtime, strftime<br /><br /># Create Log, NLPSolver, DAESolver, DataReporter, Simulation and Optimization objects<br />log          = daePythonStdOutLog()<br />daesolver    = daeIDAS()<br />nlpsolver    = daeBONMIN()<br />datareporter = daeTCPIPDataReporter()<br />simulation   = simTutorial()<br />optimization = daeOptimization()<br /><br /># Enable reporting of all variables<br />simulation.m.SetReportingOn(True)<br /><br /># Set the time horizon and the reporting interval<br />simulation.ReportingInterval = 10<br />simulation.TimeHorizon = 100<br /><br /># Connect data reporter<br />simName = simulation.m.Name + strftime(" [%d.%m.%Y %H:%M:%S]", localtime())<br />if(datareporter.Connect("", simName) == False):<br />    sys.exit()<br /><br /># Initialize the simulation<br />optimization.Initialize(simulation, nlpsolver, daesolver, datareporter, log)<br /><br /># Set the MINLP solver options (optional)<br />#nlpsolver.SetOption('OPTION', VALUE)<br />#nlpsolver.LoadOptionsFile("")<br /><br /># Save the model report and the runtime model report <br />simulation.m.SaveModelReport(simulation.m.Name + ".xml")<br />simulation.m.SaveRuntimeModelReport(simulation.m.Name + "-rt.xml")<br /><br /># Run<br />optimization.Run()<br />optimization.Finalize()<br /></a></pre>
<p><a name="Optimization">while in <span style="font-weight: bold;">cDAE</span>
by:</a></p>
<pre><a name="Optimization">// Create Log, NLPSolver, DAESolver, DataReporter, Simulation and Optimization objects<br />boost::scoped_ptr&lt;daeSimulation_t&gt;        pSimulation(new simTutorial);  <br />boost::scoped_ptr&lt;daeDataReporter_t&gt;      pDataReporter(daeCreateTCPIPDataReporter());<br />boost::scoped_ptr&lt;daeIDASolver&gt;	          pDAESolver(daeCreateIDASolver());<br />boost::scoped_ptr&lt;daeLog_t&gt;               pLog(daeCreateStdOutLog());<br />boost::scoped_ptr&lt;daeNLPSolver_t&gt;         pNLPSolver(new daeBONMINSolver());<br />boost::scoped_ptr&lt;daeOptimization_t&gt;      pOptimization(new daeOptimization());<br /><br />// Report ALL variables in the model<br />pSimulation-&gt;GetModel()-&gt;SetReportingOn(true);<br /><br />// Set the time horizon and the reporting interval<br />pSimulation-&gt;SetReportingInterval(10);<br />pSimulation-&gt;SetTimeHorizon(100);<br /> <br />// Connect data reporter<br />string strName = pSimulation-&gt;GetModel()-&gt;GetName();<br />if(!pDataReporter-&gt;Connect("", strName))<br />    return;<br /><br />// Initialize the simulation<br />pOptimization-&gt;Initialize(pSimulation.get(), <br />                          pNLPSolver.get(), <br />                          pDAESolver.get(), <br />                          pDataReporter.get(), <br />                          pLog.get());<br /><br />// Run<br />pOptimization.Run();<br />pOptimization.Finalize();<br /></a></pre>
<p><a name="Optimization">More information about simulation can be found in </a><a href="pydae_user_guide.html">pyDAE User Guide</a> and <a href="api_ref/activity.html#daeOptimization">pyDAE API Reference</a>.
Also,
do
not
forget
to
have
a
look
on
<a href="tutorials.html">tutorials</a>.</p>
<h2><a name="3._Processing_of_the_results">Processing the
results</a></h2>
<p><a name="3._Processing_of_the_results">The simulation/optimization results can be easily plotted by using <span style="font-weight: bold;">DAE Plotter</span> application. It is
possible to choose between 2D and 3D plots. After choosing a desired
type, a <span style="font-weight: bold;">Choose variable</span> (given
in <span style="font-weight: bold;">Figure 5.</span>) dialog appears
where a user has to select a variable to
plot and specify information about domains - fix some of them while
leaving another free by selecting <span style="font-weight: bold;">*</span>
from the list (to create a 2D plot you need one domain free, while for
a 3D plot you need two free domains).&nbsp; Typical 2D and 3D plots are
given in <span style="font-weight: bold;">Figures 6. and 7.</span><br />
</a></p>
<a name="3._Processing_of_the_results"><br />
</a><p><a name="3._Processing_of_the_results"><br />
</a></p>
<p style="text-align: center;"><a name="3._Processing_of_the_results"><img style="width: 663px; height: 534px;" alt="" src="images/Screenshot-ChooseVariable.png" /><br />
</a></p>
<div style="text-align: center;"><span style="font-weight: bold;"><a name="3._Processing_of_the_results">Figure
5.
Choose
variable
dialog
for
a
2D
plot<br />
</a></span></div>
<p><a name="3._Processing_of_the_results"><br />
</a></p>
<p><a name="3._Processing_of_the_results"><br />
</a></p>
<p style="text-align: center;"><a name="3._Processing_of_the_results"><img style="width: 606px; height: 484px;" alt="" src="images/Screenshot-Results.png" /><br />
</a></p>
<div style="text-align: center;"><span style="font-weight: bold;"><a name="3._Processing_of_the_results">Figure
6.
Example
2D
plot
(produced
by
Matplotlib)<br />
</a></span></div>
<p><a name="3._Processing_of_the_results"><br />
<br />
</a></p>
<p style="text-align: center;"><a name="3._Processing_of_the_results"><img style="width: 640px; height: 480px;" alt="" src="images/Screenshot-3Dplot.png" /><br />
</a></p>
<div style="text-align: center;"><span style="font-weight: bold;"><a name="3._Processing_of_the_results">Figure
7.
Example
3D
plot
(produced
by
Mayavi2)<br />
</a></span></div>
<p><a name="3._Processing_of_the_results"><br />
</a></p>
<p><a name="3._Processing_of_the_results"><br />
</a></p>
<p><a name="3._Processing_of_the_results"><br />
</a></p>
<p><a name="3._Processing_of_the_results"><br />
</a></p>
<p><a name="3._Processing_of_the_results"><br />
<br />
</a></p>
</div>
<a name="3._Processing_of_the_results"><br />
</a></div>
<!-- content-wrap ends here --><a name="3._Processing_of_the_results"> </a></div>
</div>
<!-- footer starts here -->
<div id="footer">
<div id="footer-content">
<div class="col float-left">
<p><a name="3._Processing_of_the_results">  Copyright: Dragan Nikolic 2010<br />
</a></p>
</div>
<div class="col float-left">
<p><a name="3._Processing_of_the_results"> </a><a href="http://www.daetools.com"><strong>DAE Tools Project</strong></a>
</p>
</div>
<div class="col2 float-right">
<p> Design by: <a href="http://www.styleshout.com/"><strong>Styleshout</strong></a>
&nbsp; &nbsp; Valid <a href="http://jigsaw.w3.org/css-validator/check/referer"><strong>CSS</strong></a>
| <a href="http://validator.w3.org/check/referer"><strong>XHTML</strong></a>
</p>
</div>
</div>
</div>
<!-- footer ends here --><!-- wrap ends here --> </div>

<!-- Piwik -->
<script type="text/javascript">
var pkBaseURL = (("https:" == document.location.protocol) ? "https://sourceforge.net/apps/piwik/daetools/" : "http://sourceforge.net/apps/piwik/daetools/");
document.write(unescape("%3Cscript src='" + pkBaseURL + "piwik.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var piwikTracker = Piwik.getTracker(pkBaseURL + "piwik.php", 1);
piwikTracker.trackPageView();
piwikTracker.enableLinkTracking();
} catch( err ) {}
</script><noscript>
<p><img
 src="http://sourceforge.net/apps/piwik/daetools/piwik.php?idsite=1"
 style="border: 0pt none ;" alt="" /></p>
</noscript><!-- End Piwik Tag -->
</body></html>